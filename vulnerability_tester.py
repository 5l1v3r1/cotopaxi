# -*- coding: utf-8 -*-
"""Tool for checking vulnerability of network service at given IP and port ranges."""
#
#    Copyright (C) 2019 Samsung Electronics. All Rights Reserved.
#       Author: Jakub Botwicz (Samsung R&D Poland)
#
#    This file is part of Cotopaxi.
#
#    Cotopaxi is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    Cotopaxi is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Cotopaxi.  If not, see <http://www.gnu.org/licenses/>.
#

import os
import socket
import sys
from scapy.all import Packet
from scapy.contrib.coap import CoAP
from .common_utils import CotopaxiTester, Protocol, sr1_file, protocol_enabled, \
    print_verbose, show_verbose, INPUT_BUFFER_SIZE, amplification_factor, proto_mapping
from .service_ping import service_ping


class Vulnerability(object):
    """Object representing vulnerability."""

    def __init__(self, name, cve_id, payload_file, description, url):
        self.name = name
        self.cve_id = cve_id
        self.payload_file = payload_file
        self.description = description
        self.url = url

    def print_desc(self):
        """Displays description of vulnerability"""
        if self.cve_id:
            cve_desc = " ({})".format(self.cve_id)
        else:
            cve_desc = ''
        print("{}{}: {}\nSee more at: {}\n".format(self.name, cve_desc,
                                                   self.description,
                                                   self.url))

    def get_protocol(self):
        """Returns protocol that is connected with this vulnerability."""
        proto_name = os.path.split(self.payload_file)[0]
        return {'coap': Protocol.CoAP,
                'mdns': Protocol.mDNS,
                'mqtt': Protocol.MQTT,
                'dtls': Protocol.DTLS}[proto_name]

    def verify(self, test_params):
        """Verifies whether remote host is vulnerable to this vulnerability."""
        pass

    def report_positive_result(self, test_params):
        """Report positive result of vulnerability test."""
        test_params.test_stats.active_endpoints[self.get_protocol()].append(
            "{}:{} - vuln: {}".format(test_params.dst_endpoint.ip_addr,
                                      test_params.dst_endpoint.port,
                                      self.name))

    def report_negative_result(self, test_params):
        """Report negative result of vulnerability test."""
        test_params.test_stats.inactive_endpoints[self.get_protocol()].append(
            "{}:{}".format(test_params.dst_endpoint.ip_addr,
                           test_params.dst_endpoint.port))

    def report_potential_result(self, test_params):
        """Report potential result of vulnerability test."""
        test_params.test_stats.potential_endpoints[self.get_protocol()].append(
            "{}:{} - vuln: {}".format(test_params.dst_endpoint.ip_addr,
                                      test_params.dst_endpoint.port,
                                      self.name))


def udp_sr(test_params, data, response_nr=99999, protocol=CoAP):
    """Function to send data using UDP protocol and receive multiple responses"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    if test_params.ip_version == 4:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    elif test_params.ip_version == 6:
        sock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
    sock.settimeout(test_params.timeout_sec)
    request_size = len(data)
    response_size = 0
    sock.sendto(data, (test_params.dst_endpoint.ip_addr, test_params.dst_endpoint.port))
    response = []
    count = 0
    try:
        while count < response_nr:
            in_data, server_addr = sock.recvfrom(INPUT_BUFFER_SIZE)
            response_size += len(in_data)
            response.append(in_data)
            packet = protocol(in_data)
            print_verbose(test_params, "Received packet size {} from {}\n{}"
                          .format(len(in_data), server_addr,
                                  show_verbose(test_params, packet)))
            count += 1
    except socket.timeout:
        print_verbose(test_params, "Timeout")
    print_verbose(test_params, "Request size = {}".format(request_size))
    print_verbose(test_params, "Response size = {}".format(response_size))
    return response


class NetworkTrafficAmplification(Vulnerability):
    """Object representing vulnerability leading to network traffic amplification."""

    def __init__(self, name, cve_id, payload_file, timeout_sec, nr_packets, description, url):
        Vulnerability.__init__(self, name, cve_id, payload_file, description, url)
        self.timeout_sec = timeout_sec
        self.nr_packets = nr_packets

    def verify(self, test_params):
        """Verifies whether remote host is vulnerable to this vulnerability."""
        test_params.timeout_sec = self.timeout_sec
        test_payload = None
        with open("cotopaxi/vulnerabilities/" + self.payload_file, "r") as file_handle:
            test_payload = file_handle.read()
        print("[+] Vulnerability {} is network traffic amplification.\nAfter sending payload,"
              " tool is going to wait for {} sec to count size of response packets."
              "\n(Press CTRL-C to break)"
              .format(self.name, self.timeout_sec))
        response = udp_sr(test_params, test_payload, self.nr_packets,
                          proto_mapping(self.get_protocol()))
        size = 0
        for packet in response:
            size += len(packet)
        amplify_factor = amplification_factor(len(test_payload), size)
        print_verbose(test_params, 'IN: {} bytes OUT: {} bytes AMPLIFICATION FACTOR: {:0.2f}%'
                      .format(len(test_payload), size, amplify_factor))
        if amplify_factor > 0:
            result = ""
            self.report_positive_result(test_params)
        else:
            result = "NOT "
            self.report_negative_result(test_params)

        print("[+] Server {}:{} is {}amplyfing traffic! AMPLIFICATION FACTOR: {:0.2f}%"
              .format(test_params.dst_endpoint.ip_addr,
                      test_params.dst_endpoint.port,
                      result, amplify_factor))


class Crash(Vulnerability):
    """Object representing crash vulnerability."""

    def verify(self, test_params):
        """Verifies whether remote host is vulnerable to this vulnerability."""
        alive_before = service_ping(test_params)
        if not alive_before:
            print_verbose(test_params, "[+] Server {}:{} is dead before sending payload"
                          .format(test_params.dst_endpoint.ip_addr,
                                  test_params.dst_endpoint.port))
        if not alive_before and not test_params.ignore_ping_check:
            print("[.] Vulnerability testing ({}) stopped for {}:{} because server"
                  " is not responding\n"
                  "    (use --ignore-ping-check if you want to continue anyway)!"
                  .format(self.name, test_params.dst_endpoint.ip_addr,
                          test_params.dst_endpoint.port))
            return
        test_result = sr1_file(test_params, "cotopaxi/vulnerabilities/" + self.payload_file)
        print_verbose(test_params, "[*] Payload for {} sent".format(self.name))

        if test_result is not None:
            test_result_string = "NOT"
            if test_result is Packet:
                show_verbose(test_params, test_result)
            # else:
            #     print(test_result)
        else:
            test_result_string = "probably"
        alive_after = service_ping(test_params)
        if not alive_after:
            print_verbose(test_params, "[+] Server {}:{} is dead after sending payload"
                          .format(test_params.dst_endpoint.ip_addr,
                                  test_params.dst_endpoint.port))
        if alive_before and not alive_after:
            test_result_string = "probably"
            self.report_positive_result(test_params)
        elif alive_after:
            test_result_string = "NOT"
            self.report_negative_result(test_params)

        if not alive_before and not alive_after:
            print("[+] Server {}:{} was not responding to ping before sending payload,"
                  " so you need to check result of "
                  "test directly on tested device!".format(test_params.dst_endpoint.ip_addr,
                                                           test_params.dst_endpoint.port))
            self.report_potential_result(test_params)
        else:
            print("[+] Server {}:{} is {} vulnerable to {}"
                  .format(test_params.dst_endpoint.ip_addr,
                          test_params.dst_endpoint.port,
                          test_result_string, self.name))


class MemoryLeak(Vulnerability):
    """Object representing memory leak vulnerability."""

    def verify(self, test_params):
        """Verifies whether remote host is vulnerable to this vulnerability."""
        test_result = sr1_file(test_params, "cotopaxi/vulnerabilities/" + self.payload_file)
        print("[*] Payload for {} sent".format(self.name))
        if test_result is not None:
            if test_result is Packet:
                show_verbose(test_params, test_result)
        print("[+] Vulnerability {} is memory leak - verify manually result of this test."
              .format(self.name))
        self.report_potential_result(test_params)


VULNS = {'CONTIKI_000': Crash('CONTIKI_000', "CVE-2018-19417",
                              "mqtt/payload_cve-2018-19417.raw",
                              "MQTT Broker in Contiki-NG <= 4.1 is vulnerable to "
                              "stack-based buffer overflow.",
                              "https://github.com/contiki-ng/contiki-ng/issues/600"),
         'COAPTHON3_000': Crash('COAPTHON3_000', 'CVE-2018-12679',
                                "coap/coap_payload_cve-2018-12679.raw",
                                "CoAPthon3 library is vulnerable to Denial of Service"
                                " attacks caused by maliciously crafted CoAP messages.",
                                "https://github.com/Tanganelli/CoAPthon3/issues/16"),
         'COAPTHON_000': Crash('COAPTHON_000', 'CVE-2018-12679',
                               "coap/coap_payload_cve-2018-12680.raw",
                               "CoAPthon library is vulnerable to Denial of Service"
                               " attacks caused by maliciously crafted CoAP messages.",
                               "https://github.com/Tanganelli/CoAPthon/issues/135"),
         'TINYDTLS_000': Crash('TINYDTLS_000', 'CVE-2017-7243',
                               "dtls/dtls_payload_cve-2017-7243.raw",
                               ("Eclipse tinydtls 0.8.2 for Eclipse IoT allows remote"
                                " attackers to cause a denial of service (DTLS peer"
                                " crash) by sending a 'Change cipher spec' packet"
                                " without pre-handshake. "),
                               "https://www.cvedetails.com/cve/CVE-2017-7243/"),
         'ER_COAP_000': Crash('ER_COAP_000', '',
                              "coap/coap_payload_er_coap_000.raw",
                              "Erbium CoAP server is vulnerable to memory corruption "
                              "leading to crash of the server",
                              "https://github.com/contiki-os/contiki/issues/2240"),
         'ER_COAP_001': Crash('ER_COAP_001', '',
                              "coap/coap_payload_er_coap_001.raw",
                              "Erbium CoAP server is vulnerable to memory corruption "
                              "leading to crash of the server",
                              "https://github.com/contiki-os/contiki/issues/2238"),
         'ER_COAP_002': Crash('ER_COAP_002', '',
                              "coap/coap_payload_er_coap_002.raw",
                              "Erbium CoAP server is vulnerable to memory corruption "
                              "leading to crash of the server",
                              "https://github.com/contiki-os/contiki/issues/2239"),
         'WAKAAMA_000': MemoryLeak('WAKAAMA_000', 'CVE-2019-9004',
                                   "coap/coap_payload_wakaama_000.raw",
                                   "Wakaama LWM2M server incorrectly handles incoming packets "
                                   "leading to a memory leak. Processing of the single crafted "
                                   "packet leads to leaking (wasting) 24 bytes of memory."
                                   "This can lead to stopping of the LWM2M server after "
                                   "exhausting all available memory.",
                                   "https://github.com/eclipse/wakaama/issues/425"),
         'IOTIVITY_000': NetworkTrafficAmplification('IOTIVITY_000', 'CVE-2019-9750',
                                                     "coap/coap_payload_iotivity_000.raw",
                                                     timeout_sec=10,
                                                     nr_packets=6,
                                                     description="IoTivity server  can be used to "
                                                                 "perform Distributed Denial of "
                                                                 "Service attacks acting as "
                                                                 "network amplifier with "
                                                                 "spoofing of the source IP "
                                                                 "address.",
                                                     url="https://jira.iotivity.org/browse/"
                                                         "IOT-3267"),
         'BOTAN_000': NetworkTrafficAmplification('BOTAN_000', '',
                                                  "dtls/payload_botan_000.raw",
                                                  timeout_sec=10,
                                                  nr_packets=6,
                                                  description="Botan DTLS server in versions 2.9.0"
                                                              " (and probably earlier ones) can be"
                                                              " used to perform Distributed Denial"
                                                              " of Service attacks as network "
                                                              "amplifier with spoofing of the "
                                                              "source IP address.",
                                                  url="https://github.com/randombit/botan/"
                                                      "issues/1833"),
         'TINYSVCMDNS_000': Crash('TINYSVCMDNS_000', 'CVE-2017-12087',
                                  "mdns/payload_cve-2017-12087.raw",
                                  "An exploitable heap overflow vulnerability exists in the "
                                  "tinysvcmdns library version 2016-07-18. A specially crafted"
                                  " packet can make the library overwrite an arbitrary amount "
                                  "of data on the heap with attacker controlled values. An "
                                  "attacker needs send a dns packet to trigger this vulnerability.",
                                  "https://nvd.nist.gov/vuln/detail/CVE-2017-12087"),
         'TINYSVCMDNS_001': Crash('TINYSVCMDNS_001', 'CVE-2017-12130',
                                  "mdns/payload_cve-2017-12130.raw",
                                  "An exploitable NULL pointer dereference vulnerability exists in"
                                  " the tinysvcmdns library version 2017-11-05. A specially crafted"
                                  " packet can make the library dereference a NULL pointer leading "
                                  "to a server crash and denial of service. An attacker needs to "
                                  "send a DNS query to trigger this vulnerability.",
                                  "https://nvd.nist.gov/vuln/detail/CVE-2017-12130"),
         'TINYSVCMDNS_002': Crash('TINYSVCMDNS_002', 'CVE-2019-9747',
                                  "mdns/payload_tinysvcmdns_hang_000.raw",
                                  "Maliciously crafted mDNS (Multicast DNS) packet triggers "
                                  "infinite loop while parsing mDNS query. ",
                                  "https://bitbucket.org/geekman/tinysvcmdns/issues/11/"
                                  "denial-of-service-vulnerability-infinite"),
         'FLUENTBIT_000': Crash("FLUENTBIT_000", 'CVE-2019-9749',
                                "mqtt/payload_fluent-bit_000.raw",
                                "Fluent Bit MQTT input plugin acting as MQTT broker (server) "
                                "incorrectly handles incoming network messages leading to crash "
                                "of the whole Fluent Bit server via SIGSEGV signal.",
                                "https://github.com/fluent/fluent-bit/issues/1135"),
        }

CVES = {}


def test_selected_cves(test_params, list_cves, vuln):
    """Tests vulnerability of given name against server at given IP:port."""
    if set(list_cves).intersection(["ALL", vuln.name]):
        main_test_protocol = test_params.protocol
        test_params.protocol = vuln.get_protocol()
        vuln.verify(test_params)
        test_params.protocol = main_test_protocol


def bypass_list(args):
    """Idenities whether --list or -L options were used and displays list of vulns."""
    if '--list' in args or '-L' in args:
        print("Number of vulnerabilities in database: {}\n".format(len(VULNS)))
        vulns = list(VULNS)
        vulns.sort()
        for vuln in vulns:
            VULNS[vuln].print_desc()
        exit(0)


def perform_vuln_testing(test_params, vulnerabilities):
    """Performs vulnerability testing"""
    vulns = list(VULNS)
    vulns.sort()
    for vuln_name in vulns:
        if protocol_enabled(VULNS[vuln_name].get_protocol(), test_params.protocol):
            test_selected_cves(test_params, vulnerabilities, VULNS[vuln_name])
        else:
            print_verbose(test_params, "Vulnerability {} skipped because of selection!"
                          .format(VULNS[vuln_name].name))


def main(args):
    """Starts server fingerprinting based on command line parameters"""
    bypass_list(args)

    tester = CotopaxiTester(check_ignore_ping=True)
    tester.test_params.positive_result_name = "Vulnerable endpoints"
    tester.test_params.negative_result_name = "Invulnerable endpoints"

    list_vulns = list(VULNS)
    list_vulns.append('ALL')
    list_vulns.sort()

    for vuln_name in VULNS:
        if VULNS[vuln_name].cve_id:
            CVES[VULNS[vuln_name].cve_id] = VULNS[vuln_name]

    list_cves = list(CVES)
    list_cves.append('ALL')
    list_cves.sort()

    tester.argparser.add_argument('--vuln', action='store', nargs='+',
                                  choices=list_vulns,
                                  default=['ALL'], help="list of vulnerabilities to be tested"
                                                        " (by SOFT_NUM id)")
    tester.argparser.add_argument('--cve', action='store', nargs='+',
                                  choices=list_cves,
                                  default=['ALL'], help="list of vulnerabilities to be tested "
                                                        "(by CVE id)")
    tester.argparser.add_argument('--list', '-L', action='store_true',
                                  help="display lists of all vulnerabilities supported by this tool"
                                       " with detailed description")

    options = tester.parse_args(args)
    test_params = tester.get_test_params()
    print_verbose(test_params, "selected vulnerabilities by cve: {}".format(options.cve))
    print_verbose(test_params, "selected vulnerabilities by name: {}".format(options.vuln))

    selected_vulns = options.vuln
    for cve in options.cve:
        if cve != 'ALL':
            selected_vulns.append(CVES[cve].name)
    print_verbose(test_params, "merged selected vulns by name: {}".format(selected_vulns))

    tester.perform_testing("vulnerability testing", perform_vuln_testing, selected_vulns)


if __name__ == "__main__":
    main(sys.argv[1:])
